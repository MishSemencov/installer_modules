<?php
/**
 * Request abstract class.
 *
 * @package ITHive\API
 * @author Dmitriy Gertsen <web.mackacmexa@gmail.com>
 * @copyright 2003-2016 IT-Hive
 */
namespace ITHive\API;

/**
 * Abstract request. Share methods for all type of requests.
 * @package ITHive\API
 */
abstract class Request
{
    /** @var string Action (get, getList, calc, bomb... etc) */
    protected $action;
    /** @var array Input data */
    protected $data;

    /**
     * Request constructor.
     * @param string $action Requested action
     * @param string $dataInput Data format sent (POST, stream, etc...)
     */
    public function __construct($action, $dataInput){
        $this->setAction($action);
        $this->setData($dataInput);
    }

    /**
     * Remake property by setter, if it exist!
     * @param $name
     * @param $value
     * @return $this
     * @throws Error
     */
    public function __set($name, $value)
    {
        $setter = 'set' . ucfirst($name);
        if (method_exists($this, $setter)) {
            $this->$setter($value);
        } else {
            // TODO: simplify all this
            $dataNamespace = $this->getDataNamespace();
            $isObjectArray = false;
            // none entities save as is
            if (!class_exists($dataNamespace . "\\Data\\" . $name)) {
                // isn't it an array of entities?
                if (class_exists($dataNamespace . "\\Data\\" . substr($name, 0, -1))) {
                    $isObjectArray = true;
                } else {
                    $this->$name = $value;
                    return $this;
                }
            }
            // entities? lets construct them
            $className = $dataNamespace . "\\Data\\" . $name;
            if ($isObjectArray) {
                $className = substr($className, 0, -1);
                $array = array();
                foreach ($value as $object) {
                    $array[] = new $className($object); // may throw error, if params will not validated
                }
                $this->$name = $array;
            } else {
                $this->$name = new $className($value); // may throw error, if params will not validated
            }
//            throw new Error('Resend property ' . $name . ' not exist in ' . get_called_class());
        }

        return $this;
    }

    /**
     * Get namespace of api data classes
     * @return string
     */
    protected function getDataNamespace(){
        $class = explode('\\', get_called_class());
        array_pop($class);
        return implode('\\', $class);
    }

    /**
     * Check list of required and filled properties in object generated by this class
     * @param array $list
     * @throws Error
     */
    protected function checkRequired(array $list){
        foreach ($list as $param) {
            if (!(property_exists($this, $param)) || is_null($this->$param) || (empty($this->$param) && $this->$param !== false)) {
                throw new Error('Absent or empty required parameter: ' . $param, Error::API_ERR_PARAM_REQUIRED);
            }
        }
    }

    /**
     * It's a setter.
     * Check and set action property by posted action type
     * @param string $action
     * @throws Error
     */
    protected function setAction($action)
    {
        // validate and filtering
        $actionString = strtolower(trim($action, '/'));

        // error or default action
        if (empty($actionString)) {
            if (!empty($action)) {
                throw new Error('Action not specified', Error::API_ERR_ACTION);
            } else {
                $actionString = 'get';
            }
        }

        // get renamed action string if it is
        $specialList = array('getList' => 'list', 'getProfile' => 'profile', 'getById' => 'id/by', 'getStatusList' => 'list/status', 'setFlight' => 'flight'); // renamed actions list (full action strings)
        $actionString = array_search($actionString, $specialList) ?: $actionString;
        // get all actions
        $arAction = array_reverse(explode('/', $actionString));
        $action = array_shift($arAction);
        if (count($arAction) > 0) {
            $arAction = array_map(
                function ($a) {
                    return ucfirst($a);
                },
                $arAction
            );
            $action .= implode('', $arAction);
        }

        // error, not exists action
        $interface = array_pop(class_implements($this));
        if (!method_exists($interface, $action)) {
            throw new Error('Action "' . $action . '" not found in entity api interface "' . $interface . '"', Error::API_ERR_ACTION);
        }

        $this->action = $action;
    }

    /**
     * It's a setter.
     * Check input data type and set data property
     * Also fill in the values to the object properties of the received keys, as the name of the object property
     * @param $inputType
     * @return array|void
     * @throws Error
     */
    protected function setData($inputType)
    {
        switch ($inputType) {
            case 'post':
                $arData = $_POST;
                $data = array();
                foreach ($arData as $k => $v) {
                    if(is_null($v)) continue;
                    $data[$k] = $this->parseJSON($v, true);
                }
                break;
            case 'stream':
                $arData = file_get_contents('php://input');
                $data = $this->parseJSON($arData, true);
                break;
            default:
                $data = array();
        }

        $this->data = $data;

        Api::log($arData, 'data');

        if (is_array($this->data)) {
            foreach ($this->data as $k => $v) {
                $this->$k = $v;
            }
        }
    }

    /**
     * Parse input json and return
     * @param $data
     * @param bool $assoc As assoc array?
     * @return mixed
     * @throws Error
     */
    protected function parseJSON($data, $assoc = true){
        $data = filter_var($data);
        $data = json_decode($data, $assoc);
        if ($jsonError = json_last_error()) {
//        var_dump(JSON_ERROR_NONE); // 0
//        var_dump(JSON_ERROR_DEPTH); // 1
//        var_dump(JSON_ERROR_STATE_MISMATCH); // 2
//        var_dump(JSON_ERROR_CTRL_CHAR); // 3
//        var_dump(JSON_ERROR_SYNTAX); // 4
//        var_dump(JSON_ERROR_UTF8); // 5
//        var_dump(JSON_ERROR_RECURSION); // 20
//        var_dump(JSON_ERROR_INF_OR_NAN);
//        var_dump(JSON_ERROR_UNSUPPORTED_TYPE);
            // for php > 5.5 we can use json_last_error_msg()
            throw new Error('There is some error at syntax JSON or encoding! Error code: ' . $jsonError, Error::API_ERR_JSON);
        }

        return $data;
    }

    /**
     * Call api method by different request entity
     * @return mixed
     */
    public function call()
    {
        return call_user_func(array($this, $this->action));
    }
}